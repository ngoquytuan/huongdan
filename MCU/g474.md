Có. Với **Keil µVision (Arm Compiler) + STM32 HAL**, “một số tính năng chạy một thời gian rồi biến mất” rất hay gặp khi **stack overflow** hoặc **bị ghi đè RAM** (stack đè lên `.bss/.data`, heap, buffer DMA…). Dưới đây là các cách **bắt bệnh + xử lý** theo thứ tự hiệu quả/nhanh nhất.

---

## 1) Tăng stack đúng chỗ trong Keil (để loại trừ ngay)

Trong Keil, kích thước stack thường được quyết định bởi **startup file**:

* `startup_stm32g474xx.s` (hoặc tương tự)

  * Có các symbol như `Stack_Size` (và `Heap_Size`)

Bạn vào file startup và tìm đoạn kiểu:

```asm
Stack_Size      EQU     0x00000400
Heap_Size       EQU     0x00000200
```

➡️ Thử tăng `Stack_Size` lên **0x1000 (4KB)** hoặc **0x2000 (8KB)** để xem lỗi có biến mất không.

Ngoài ra kiểm tra trong µVision:

* **Project → Options for Target → Target**: đọc “IRAM1 size” đúng với RAM thật.
* **Options → Linker**: nếu dùng scatter file, stack/heap có thể nằm trong scatter thay vì startup.

> Nếu tăng stack mà hết hiện tượng → 90% là stack overflow hoặc gần overflow.

---

## 2) Bật “stack usage / runtime check” của Keil (bắt sớm)

Keil có cơ chế phát hiện stack/heap va chạm và stack overflow tùy cấu hình thư viện runtime.

Trong µVision:

* **Options for Target → C/C++**

  * bật **“One ELF Section per Function”** (giúp map dễ đọc, không bắt buộc)
* **Options for Target → Linker**

  * bật **Map File** (Output → Create MAP file)

Sau đó bạn có thể:

* xem **map file** để biết **stack đặt ở đâu**, còn trống bao nhiêu RAM.

Nếu bạn dùng **Microlib**, một số cơ chế check khác đi; nhưng map file vẫn là nguồn chuẩn.

---

## 3) Đo “stack high-water mark” ngay trên firmware (rất hiệu quả)

Ý tưởng: lúc boot, **fill vùng stack bằng pattern**, chạy một thời gian rồi **kiểm tra còn lại bao nhiêu pattern** ⇒ biết stack đã dùng tối đa bao nhiêu.

### Với Keil/ARMCC, cách làm thực dụng:

1. Tìm địa chỉ stack trong map / startup:

   * `__initial_sp` = đỉnh stack
   * vùng stack thường nằm cuối IRAM.

2. Bạn có thể “paint” một khoảng dưới `__initial_sp` (bạn biết kích thước stack bạn cấu hình) rồi kiểm tra.

Ví dụ C (không phụ thuộc symbol phức tạp, chỉ cần bạn khai báo đúng Stack_Size):

```c
#include <stdint.h>
#include <stddef.h>

extern uint32_t __initial_sp;      // Keil startup export
#define STACK_SIZE_BYTES (0x1000u) // phải khớp Stack_Size bạn đang dùng
#define PATTERN 0xA5A5A5A5u

static inline uint32_t* stack_bottom(void){
  return (uint32_t*)((uint32_t)&__initial_sp - STACK_SIZE_BYTES);
}
static inline uint32_t* stack_top(void){
  return (uint32_t*)&__initial_sp;
}

void StackPaint(void){
  uint32_t *p = stack_bottom();
  while (p < stack_top()) *p++ = PATTERN;
}

size_t StackHighWaterBytes(void){
  uint32_t *p = stack_bottom();
  while (p < stack_top() && *p == PATTERN) p++;
  return (size_t)((uint8_t*)stack_top() - (uint8_t*)p);
}
```

* Gọi `StackPaint()` **rất sớm** (đầu `main()` ngay sau `HAL_Init()` hoặc thậm chí trước nếu bạn chắc).
* Thỉnh thoảng log `StackHighWaterBytes()` ra UART/RTT.
* Nếu high-water tiến sát `STACK_SIZE_BYTES` (ví dụ >80–90%) ⇒ bạn gần overflow.

> Cách này bắt được cả “đã từng dùng tới đâu” dù hiện tại SP đã quay lên.

---

## 4) Bẫy HardFault để biết có phải stack đè bậy không (debug chuẩn)

Nếu stack overflow dẫn tới HardFault, hãy sửa handler để lấy:

* `MSP/PSP`
* `PC/LR`
* các thanh ghi stacked

Bạn có thể thêm HardFault handler “có log” (Keil) để in ra PC/LR hoặc dừng breakpoint, từ đó truy ra hàm nào làm stack bùng.

Nếu bạn muốn, bạn paste HardFault_Handler hiện tại của bạn, mình sẽ đưa bản “drop-in” phù hợp STM32/Keil để dump regs.

---

## 5) Những nguyên nhân phổ biến làm stack “phình” theo thời gian

Các “thủ phạm” hay gặp với HAL:

* **Mảng local lớn trong hàm** (đặc biệt trong callback IRQ, hoặc trong task loop)

  * VD: `uint8_t buf[2048];` đặt trong function → stack tăng đột biến.
  * Giải pháp: đưa ra **static/global**, hoặc cấp phát từ heap (cẩn thận), hoặc chia nhỏ.

* **printf/sprintf** (newlib/stdio) ăn stack mạnh và có thể phân mảnh heap

  * Giải pháp: dùng `snprintf` có giới hạn; hạn chế float format; dùng lightweight printf.

* **Recursion / call chain sâu** (đặc biệt trong state machine gọi lồng nhau)

  * Giải pháp: chuyển recursion thành vòng lặp, flatten call depth.

* **Interrupt lồng nhau / callback HAL** gọi nhiều tầng

  * ISR nên cực gọn; tránh gọi hàm nặng/printf trong ISR.

* **Heap/stack collision** (nếu bạn có malloc, hoặc thư viện dùng heap ngầm)

  * Tăng khoảng cách hoặc tắt heap nếu không dùng.

* **DMA buffer đặt trên stack** (rất nguy hiểm)

  * DMA cần buffer tồn tại lâu; đặt stack sẽ “mất” sau khi hàm return.

---

## 6) “Cách xử lý” nhanh nhất theo thực chiến (khuyên làm theo thứ tự)

1. **Tăng Stack_Size** lên 4KB/8KB để xem triệu chứng còn không.
2. Thêm **StackPaint + HighWater** để đo thực tế sau vài phút/hours chạy.
3. Nếu high-water cao:

   * tìm hàm gây phình (soát mảng local, printf, callback ISR)
   * chuyển buffer lớn ra global/static
   * giảm call depth
4. Nếu vẫn khó: thêm **HardFault dump** + bật map file để truy PC/LR.

---

## Để mình khoanh đúng hơn (không cần bạn trả lời dài)

Bạn chỉ cần paste 3 thứ là mình có thể chỉ chính xác chỗ set stack và viết đoạn đo đúng symbol Keil của project bạn:

1. Đoạn trong `startup_stm32g474xx.s` có `Stack_Size` / `__initial_sp`
2. Bạn đang set Stack_Size bao nhiêu (0x400? 0x800?)
3. Có dùng **FreeRTOS** không? (nếu có thì ngoài “main stack”, mỗi task còn stack riêng)

Bạn paste 20–40 dòng quanh `Stack_Size` là đủ.


### 1) “Stack của STM32G474” là bao nhiêu?

**STM32G474 không có một “dung lượng stack cố định”.** Stack chỉ là **một vùng bạn dành ra trong SRAM** và **kích thước do linker/startup của project quyết định** (ví dụ `_Min_Stack_Size` trong file `.ld`, hoặc `__ICFEDIT_size_cstack__` với IAR, v.v.).

Con **STM32G474 (Cortex-M4)** có tổng RAM nội khá lớn, gồm:

* **96 KB SRAM** + **32 KB CCM SRAM (routine booster)** (tổng 128 KB) theo datasheet. ([STMicroelectronics][1])

Nhưng **stack chỉ lấy một phần** của RAM đó (phần còn lại cho `.data/.bss`, heap, buffer, RTOS task stacks…).

> Nhiều project mẫu / mặc định của STM32CubeIDE/IAR hay để stack rất nhỏ kiểu **0x400 (1024 byte)** và heap **0x200**, nhưng đó chỉ là **default của template**, không phải giới hạn phần cứng. ([community.st.com][2])

---

### 2) Khi nào biết stack “hết” (stack overflow)?

Trên Cortex-M, stack thường **tăng từ địa chỉ cao xuống thấp**. Khi **SP (MSP/PSP) chạy xuống thấp hơn đáy vùng stack bạn cấp**, là overflow. Thực tế bạn hay “biết” qua 3 cách:

#### Cách A — Bị crash/HardFault (dấu hiệu muộn)

Overflow có thể **đè lên biến global/heap/stack khác**, gây:

* HardFault / MemManageFault (nếu có bảo vệ),
* chương trình “chạy lung tung”, dữ liệu sai, reset ngẫu nhiên…

#### Cách B — Đo “high-water mark” bằng canary pattern (cách thực dụng nhất)

Ý tưởng: lúc boot, **đổ một pattern** (vd `0xA5`) vào toàn bộ vùng stack; chạy một thời gian rồi **đếm xem pattern bị ghi đè đến đâu** → biết stack đã dùng tối đa bao nhiêu. Đây là cách rất phổ biến trong embedded. ([MCU on Eclipse][3])

Ví dụ (GCC/CubeIDE, dựa vào symbol của linker – bạn cần đúng tên symbol theo project của bạn):

```c
#include <stdint.h>
#include <stddef.h>

// Tùy linker script, tên symbol có thể là: _estack, _sstack, __StackTop, __StackLimit...
extern uint32_t __StackLimit;   // đáy stack (địa chỉ thấp)
extern uint32_t __StackTop;     // đỉnh stack (địa chỉ cao)

#define STACK_PATTERN 0xA5A5A5A5u

void StackPaint(void) {
  uint32_t *p = &__StackLimit;
  while (p < &__StackTop) {
    *p++ = STACK_PATTERN;
  }
}

size_t StackHighWaterBytes(void) {
  uint32_t *p = &__StackLimit;
  while (p < &__StackTop && *p == STACK_PATTERN) {
    p++;
  }
  return (size_t)((uint8_t*)&__StackTop - (uint8_t*)p); // số byte đã từng bị dùng tối đa
}
```

* Gọi `StackPaint()` rất sớm (đầu `main()` sau init tối thiểu).
* Thỉnh thoảng gọi `StackHighWaterBytes()` để log/telemetry.

#### Cách C — Bảo vệ bằng MPU “guard band” (phát hiện sớm)

Bạn có thể cấu hình **MPU** đặt **một vùng “no-access” ngay dưới đáy stack**. Khi stack chạm vào sẽ tạo fault ngay, dễ debug. (STM32G474 có MPU vì là Cortex-M4). ([STMicroelectronics][1])

---

### 3) Biết trước (compile-time) stack có đủ không?

* Dùng **phân tích tĩnh** (static stack analysis) / báo cáo stack usage của compiler. STM32CubeIDE có công cụ liên quan, nhưng vẫn cần bạn theo dõi vì nó không luôn “bắt lỗi” theo RAM thực tế. ([Electrical Engineering Stack Exchange][4])
* Với GCC, bạn cũng có thể bật `-fstack-usage` để tạo file `.su` cho từng hàm (rất hữu ích khi nghi hàm nào ăn stack).

---

### Gợi ý nhanh để bạn tự kiểm tra project của mình

1. Mở file linker (`*.ld`) và tìm `_Min_Stack_Size` (hoặc tương đương) → đó là **stack bạn đang cấp**.
2. Chạy firmware, bật **canary/high-water mark** để biết “đỉnh dùng” thực tế.
3. Chừa **margin** (thường 30–50% tùy mức an toàn) và đặc biệt cẩn thận với:

   * mảng local lớn (`uint8_t buf[4096];`),
   * `printf`/`sprintf`,
   * recursion,
   * ISR gọi hàm sâu,
   * RTOS (mỗi task có stack riêng).

Nếu bạn cho mình biết bạn đang dùng **bare-metal hay FreeRTOS**, và toolchain **CubeIDE (GCC) / Keil / IAR**, mình sẽ chỉ đúng vị trí stack setting + đúng tên symbol để đo high-water mark “chuẩn bài” cho project của bạn.

[1]: https://www.st.com/resource/en/datasheet/stm32g474cb.pdf "Datasheet - STM32G474xB STM32G474xC STM32G474xE - Arm® Cortex®-M4 32-bit MCU+FPU, 170 MHz / 213 DMIPS, 128 KB SRAM, rich analog, math acc, 184 ps 12 chan Hi-res timer"
[2]: https://community.st.com/t5/stm32cubeide-mcus/stmcubeide-defaults/td-p/357299?utm_source=chatgpt.com "STMCubeIDE Defaults - STMicroelectronics Community"
[3]: https://mcuoneclipse.com/2023/02/19/avoiding-stack-overflows-application-monitoring-the-stack-usage/?utm_source=chatgpt.com "Avoiding Stack Overflows: Application Monitoring the Stack Usage"
[4]: https://electronics.stackexchange.com/questions/649820/how-to-use-stm32cube-static-stack-analyzer-as-an-automatic-compile-time-sanity-c?utm_source=chatgpt.com "stm32 - How to use STM32Cube Static Stack Analyzer as an automatic ..."
