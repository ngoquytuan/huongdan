### 1) “Stack của STM32G474” là bao nhiêu?

**STM32G474 không có một “dung lượng stack cố định”.** Stack chỉ là **một vùng bạn dành ra trong SRAM** và **kích thước do linker/startup của project quyết định** (ví dụ `_Min_Stack_Size` trong file `.ld`, hoặc `__ICFEDIT_size_cstack__` với IAR, v.v.).

Con **STM32G474 (Cortex-M4)** có tổng RAM nội khá lớn, gồm:

* **96 KB SRAM** + **32 KB CCM SRAM (routine booster)** (tổng 128 KB) theo datasheet. ([STMicroelectronics][1])

Nhưng **stack chỉ lấy một phần** của RAM đó (phần còn lại cho `.data/.bss`, heap, buffer, RTOS task stacks…).

> Nhiều project mẫu / mặc định của STM32CubeIDE/IAR hay để stack rất nhỏ kiểu **0x400 (1024 byte)** và heap **0x200**, nhưng đó chỉ là **default của template**, không phải giới hạn phần cứng. ([community.st.com][2])

---

### 2) Khi nào biết stack “hết” (stack overflow)?

Trên Cortex-M, stack thường **tăng từ địa chỉ cao xuống thấp**. Khi **SP (MSP/PSP) chạy xuống thấp hơn đáy vùng stack bạn cấp**, là overflow. Thực tế bạn hay “biết” qua 3 cách:

#### Cách A — Bị crash/HardFault (dấu hiệu muộn)

Overflow có thể **đè lên biến global/heap/stack khác**, gây:

* HardFault / MemManageFault (nếu có bảo vệ),
* chương trình “chạy lung tung”, dữ liệu sai, reset ngẫu nhiên…

#### Cách B — Đo “high-water mark” bằng canary pattern (cách thực dụng nhất)

Ý tưởng: lúc boot, **đổ một pattern** (vd `0xA5`) vào toàn bộ vùng stack; chạy một thời gian rồi **đếm xem pattern bị ghi đè đến đâu** → biết stack đã dùng tối đa bao nhiêu. Đây là cách rất phổ biến trong embedded. ([MCU on Eclipse][3])

Ví dụ (GCC/CubeIDE, dựa vào symbol của linker – bạn cần đúng tên symbol theo project của bạn):

```c
#include <stdint.h>
#include <stddef.h>

// Tùy linker script, tên symbol có thể là: _estack, _sstack, __StackTop, __StackLimit...
extern uint32_t __StackLimit;   // đáy stack (địa chỉ thấp)
extern uint32_t __StackTop;     // đỉnh stack (địa chỉ cao)

#define STACK_PATTERN 0xA5A5A5A5u

void StackPaint(void) {
  uint32_t *p = &__StackLimit;
  while (p < &__StackTop) {
    *p++ = STACK_PATTERN;
  }
}

size_t StackHighWaterBytes(void) {
  uint32_t *p = &__StackLimit;
  while (p < &__StackTop && *p == STACK_PATTERN) {
    p++;
  }
  return (size_t)((uint8_t*)&__StackTop - (uint8_t*)p); // số byte đã từng bị dùng tối đa
}
```

* Gọi `StackPaint()` rất sớm (đầu `main()` sau init tối thiểu).
* Thỉnh thoảng gọi `StackHighWaterBytes()` để log/telemetry.

#### Cách C — Bảo vệ bằng MPU “guard band” (phát hiện sớm)

Bạn có thể cấu hình **MPU** đặt **một vùng “no-access” ngay dưới đáy stack**. Khi stack chạm vào sẽ tạo fault ngay, dễ debug. (STM32G474 có MPU vì là Cortex-M4). ([STMicroelectronics][1])

---

### 3) Biết trước (compile-time) stack có đủ không?

* Dùng **phân tích tĩnh** (static stack analysis) / báo cáo stack usage của compiler. STM32CubeIDE có công cụ liên quan, nhưng vẫn cần bạn theo dõi vì nó không luôn “bắt lỗi” theo RAM thực tế. ([Electrical Engineering Stack Exchange][4])
* Với GCC, bạn cũng có thể bật `-fstack-usage` để tạo file `.su` cho từng hàm (rất hữu ích khi nghi hàm nào ăn stack).

---

### Gợi ý nhanh để bạn tự kiểm tra project của mình

1. Mở file linker (`*.ld`) và tìm `_Min_Stack_Size` (hoặc tương đương) → đó là **stack bạn đang cấp**.
2. Chạy firmware, bật **canary/high-water mark** để biết “đỉnh dùng” thực tế.
3. Chừa **margin** (thường 30–50% tùy mức an toàn) và đặc biệt cẩn thận với:

   * mảng local lớn (`uint8_t buf[4096];`),
   * `printf`/`sprintf`,
   * recursion,
   * ISR gọi hàm sâu,
   * RTOS (mỗi task có stack riêng).

Nếu bạn cho mình biết bạn đang dùng **bare-metal hay FreeRTOS**, và toolchain **CubeIDE (GCC) / Keil / IAR**, mình sẽ chỉ đúng vị trí stack setting + đúng tên symbol để đo high-water mark “chuẩn bài” cho project của bạn.

[1]: https://www.st.com/resource/en/datasheet/stm32g474cb.pdf "Datasheet - STM32G474xB STM32G474xC STM32G474xE - Arm® Cortex®-M4 32-bit MCU+FPU, 170 MHz / 213 DMIPS, 128 KB SRAM, rich analog, math acc, 184 ps 12 chan Hi-res timer"
[2]: https://community.st.com/t5/stm32cubeide-mcus/stmcubeide-defaults/td-p/357299?utm_source=chatgpt.com "STMCubeIDE Defaults - STMicroelectronics Community"
[3]: https://mcuoneclipse.com/2023/02/19/avoiding-stack-overflows-application-monitoring-the-stack-usage/?utm_source=chatgpt.com "Avoiding Stack Overflows: Application Monitoring the Stack Usage"
[4]: https://electronics.stackexchange.com/questions/649820/how-to-use-stm32cube-static-stack-analyzer-as-an-automatic-compile-time-sanity-c?utm_source=chatgpt.com "stm32 - How to use STM32Cube Static Stack Analyzer as an automatic ..."
