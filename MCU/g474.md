Con số này **đúng kiểu “đẹp”** và giải thích vì sao bạn “không thấy stack tăng theo thời gian”:

* `used=1664 / 4096` là **high-water mark** (đỉnh stack lớn nhất *đã từng* dùng kể từ lúc bạn “paint”), **không phải** “stack đang dùng hiện tại”.
* Nếu sau vài phút / vài giờ mà vẫn 1664 ⇒ nghĩa là trong quá trình chạy, call depth/printf/ISR… **không hề vượt qua mức đỉnh đó**. Đây là hoàn toàn bình thường.

Và điều quan trọng: **khi bạn tăng stack lên 0x1000 mà “fix luôn”** thì khả năng rất cao là trước đó bạn **đang sát/đụng đáy stack** (đặc biệt do `LOG_DEBUG/printf`), làm ghi đè RAM và “tính năng biến mất” sau một thời gian.

---

## 1) Bạn còn bị overflow không?

Với `4096 - 1664 = 2432 bytes` margin, thường là **an toàn** cho bare-metal (không RTOS) nếu không có path nào hiếm gặp làm stack bùng.

Nhưng để chắc ăn, bạn nên “đánh” thêm các tình huống làm stack cao nhất:

* bật tất cả tính năng cùng lúc (worst-case)
* spam interrupt / communication bursts (UART RX, timer callbacks…)
* chạy đoạn code hay gây sâu call (protocol parse, CRC, log…)

Nếu `used` nhảy lên đáng kể khi “stress” ⇒ số đo của bạn đang phản ánh đúng.

---

## 2) Vì sao trước đó lỗi “biến mất” sau thời gian dài?

Nếu tăng stack đã hết, thường có 2 cơ chế:

1. **Tràn stack đè lên biến/buffer** → chạy một lúc mới lộ ra (dữ liệu bị phá từ từ).
2. **Stack/heap collision** (nếu có malloc hoặc thư viện dùng heap) → heap lớn dần rồi chạm stack.

Bạn có dùng `malloc/new`, `printf` buffer nội, hoặc bất kỳ thư viện nào cấp phát động không? Nếu có, nên kiểm tra collision.

---

## 3) Kiểm tra nhanh để xác nhận bạn đo đúng (không bị “ảo”)

Trong Keil Debug:

* xem register **MSP** lúc chạy
* Watch:

  * `&__stack_limit` (hoặc đáy stack bạn dùng)
  * `&__initial_sp` (đỉnh stack)

Đảm bảo luôn đúng:
`stack_bottom < MSP <= stack_top`

Nếu đúng, high-water 1664 là đáng tin.

---

## 4) Nếu muốn “bắt tại trận” khi stack chạm đáy (bảo vệ cứng)

Cách chắc nhất là tạo **guard** ở đáy stack:

### Guard pattern (nhẹ, rất hiệu quả)

* Chừa 32–64 bytes ở đáy stack làm “canary”
* Mỗi 1–10s kiểm tra có bị thay đổi không
* Nếu đổi → báo động/Reset/log

Ví dụ:

```c
#define GUARD_WORDS 16
static uint32_t *guard = (uint32_t*)&__stack_limit;

void StackGuardInit(void){
  for(int i=0;i<GUARD_WORDS;i++) guard[i]=0xDEADBEEFu;
}

int StackGuardOk(void){
  for(int i=0;i<GUARD_WORDS;i++) if(guard[i]!=0xDEADBEEFu) return 0;
  return 1;
}
```

Nếu guard hỏng mà high-water vẫn chưa max, thì bạn đang bị **ghi đè RAM từ nguồn khác** (DMA/buffer overflow), không phải stack.

---

## 5) Nếu giờ stack ổn mà thỉnh thoảng vẫn “mất tính năng” → nghi memory corruption khác

Những thủ phạm phổ biến (rất hay gặp với HAL):

* **Buffer overflow** (copy/parse frame, `sprintf`, `strcpy`, index sai)
* **DMA buffer đặt trên stack** hoặc buffer hết vòng đời
* **Concurrency/ISR**: biến dùng chung không `volatile`, race condition
* **HAL callback** làm việc nặng / gọi log trong ISR
* **Heap fragmentation** (nếu có malloc) → chạy lâu mới lộ

Cách “soi” nhanh:

1. Bật **compiler warnings** cao nhất, rà soát `memcpy/strcpy/sprintf`.
2. Thêm **assert** + kiểm tra bounds cho các buffer quan trọng.
3. Với DMA/UART RX: đảm bảo buffer **static/global**, không phải local.
4. Tạo **watchpoint** (DWT) trên biến “bị mất” để xem ai ghi vào nó.

---

## Kết luận từ số bạn đưa

* `used=1664 / 4096` + tăng stack từ 0x500 lên 0x1000 mà hết lỗi ⇒ **rất nhiều khả năng nguyên nhân gốc là stack overflow** (hoặc sát overflow) trước đây.
* Hiện tại stack **có vẻ ổn**.

Nếu bạn muốn mình khoanh “chính xác cái gì đã ăn stack”: paste giúp mình:

* macro/implementation của `LOG_DEBUG` (nó dùng `printf`/`vsnprintf` thế nào)
* có dùng `float printf` không
* có ISR nào gọi log không

Mình sẽ chỉ ra chỗ nào thường làm stack bùng và cách giảm (giữ stack nhỏ lại mà vẫn ổn).


Đúng rồi — **không phải Keil “không load được”**, mà là do trong `startup_stm32g474xx.s` **label `Stack_Mem` không được EXPORT**, nên từ C (`main.c`) linker không nhìn thấy ⇒ báo *Undefined symbol Stack_Mem*.

Trong template startup của Keil/STM hay gặp dạng:

```asm
Stack_Size      EQU     0x00000500

                AREA    STACK, NOINIT, READWRITE, ALIGN=3
__stack_limit
Stack_Mem       SPACE   Stack_Size
__initial_sp
```

Thường thì file startup sẽ **EXPORT `__initial_sp`** và **EXPORT `__stack_limit`**, còn **`Stack_Mem` thì không export**.

Bạn có 2 cách fix (mình khuyên cách 1 vì “đúng chuẩn Keil”):

---

## Cách 1 (khuyên dùng): Dùng `__stack_limit` làm đáy stack

Bạn đổi code C sang dùng symbol **đã export**:

```c
#include "cmsis_armcc.h"  // hoặc core_cm4.h (tùy project)
#include <stdint.h>
#include <stddef.h>

extern uint32_t __initial_sp;     // đỉnh stack
extern uint32_t __stack_limit;    // đáy stack (đúng cái bạn cần)

#define PATTERN 0xA5A5A5A5u

static inline uint32_t* stack_bottom(void){ return &__stack_limit; }
static inline uint32_t* stack_top(void){    return &__initial_sp; }

void StackPaint_MSP(void)
{
  __disable_irq();
  uint32_t *p = stack_bottom();
  uint32_t *limit = (uint32_t*)__get_MSP();      // chỉ fill đến SP hiện tại
  while (p < limit) *p++ = PATTERN;
  __enable_irq();
}

size_t StackHighWaterBytes_MSP(void)
{
  uint32_t *p = stack_bottom();
  uint32_t *top = stack_top();
  while (p < top && *p == PATTERN) p++;
  return (size_t)((uint8_t*)top - (uint8_t*)p);
}
```

✅ Ưu điểm: không cần sửa startup, rất sạch.

> Nếu project bạn **không có `__stack_limit`**, bạn mở `startup_*.s` và search `EXPORT` xem họ export tên gì (nhiều khi là `__StackLimit`/`__stack_base`…).

---

## Cách 2: Export `Stack_Mem` trong startup

Trong `startup_stm32g474xx.s`, thêm:

```asm
                EXPORT  Stack_Mem
```

(đặt gần các dòng `EXPORT __initial_sp`/`EXPORT __stack_limit`)

Sau đó bạn có thể `extern uint32_t Stack_Mem;` bên C.

✅ Ưu: bạn giữ code C như cũ
⚠️ Nhược: sửa startup (không sao, nhưng hay bị overwrite nếu bạn regenerate project).

---

## Một lưu ý cực quan trọng

Với stack chỉ **0x500 = 1280 bytes**, chỉ riêng `LOG_DEBUG/printf` có thể làm stack tụt sâu. Vì bạn đang nghi overflow, mình khuyên bạn **tạm nâng lên 0x1000 hoặc 0x2000** để:

* xác nhận bệnh có phải stack không,
* rồi mới tối ưu lại.

---

## Bạn làm bước tiếp theo thế này cho chắc

1. Mở `startup_stm32g474xx.s` → tìm đoạn stack → xem có `__stack_limit` không.
2. Nếu có: dùng **Cách 1**.
3. In log thêm tổng stack cho dễ nhìn:

```c
LOG_DEBUG("Stack", "used=%u / %u",
          (unsigned)StackHighWaterBytes_MSP(),
          (unsigned)((uint8_t*)&__initial_sp - (uint8_t*)&__stack_limit));
```

Nếu bạn paste 15–30 dòng trong startup quanh phần stack (bao gồm các `EXPORT`), mình sẽ chỉ đúng tên symbol bạn nên `extern` trong C để build phát ăn ngay.


Có. Với **Keil µVision (Arm Compiler) + STM32 HAL**, “một số tính năng chạy một thời gian rồi biến mất” rất hay gặp khi **stack overflow** hoặc **bị ghi đè RAM** (stack đè lên `.bss/.data`, heap, buffer DMA…). Dưới đây là các cách **bắt bệnh + xử lý** theo thứ tự hiệu quả/nhanh nhất.

---

## 1) Tăng stack đúng chỗ trong Keil (để loại trừ ngay)

Trong Keil, kích thước stack thường được quyết định bởi **startup file**:

* `startup_stm32g474xx.s` (hoặc tương tự)

  * Có các symbol như `Stack_Size` (và `Heap_Size`)

Bạn vào file startup và tìm đoạn kiểu:

```asm
Stack_Size      EQU     0x00000400
Heap_Size       EQU     0x00000200
```

➡️ Thử tăng `Stack_Size` lên **0x1000 (4KB)** hoặc **0x2000 (8KB)** để xem lỗi có biến mất không.

Ngoài ra kiểm tra trong µVision:

* **Project → Options for Target → Target**: đọc “IRAM1 size” đúng với RAM thật.
* **Options → Linker**: nếu dùng scatter file, stack/heap có thể nằm trong scatter thay vì startup.

> Nếu tăng stack mà hết hiện tượng → 90% là stack overflow hoặc gần overflow.

---

## 2) Bật “stack usage / runtime check” của Keil (bắt sớm)

Keil có cơ chế phát hiện stack/heap va chạm và stack overflow tùy cấu hình thư viện runtime.

Trong µVision:

* **Options for Target → C/C++**

  * bật **“One ELF Section per Function”** (giúp map dễ đọc, không bắt buộc)
* **Options for Target → Linker**

  * bật **Map File** (Output → Create MAP file)

Sau đó bạn có thể:

* xem **map file** để biết **stack đặt ở đâu**, còn trống bao nhiêu RAM.

Nếu bạn dùng **Microlib**, một số cơ chế check khác đi; nhưng map file vẫn là nguồn chuẩn.

---

## 3) Đo “stack high-water mark” ngay trên firmware (rất hiệu quả)

Ý tưởng: lúc boot, **fill vùng stack bằng pattern**, chạy một thời gian rồi **kiểm tra còn lại bao nhiêu pattern** ⇒ biết stack đã dùng tối đa bao nhiêu.

### Với Keil/ARMCC, cách làm thực dụng:

1. Tìm địa chỉ stack trong map / startup:

   * `__initial_sp` = đỉnh stack
   * vùng stack thường nằm cuối IRAM.

2. Bạn có thể “paint” một khoảng dưới `__initial_sp` (bạn biết kích thước stack bạn cấu hình) rồi kiểm tra.

Ví dụ C (không phụ thuộc symbol phức tạp, chỉ cần bạn khai báo đúng Stack_Size):

```c
#include <stdint.h>
#include <stddef.h>

extern uint32_t __initial_sp;      // Keil startup export
#define STACK_SIZE_BYTES (0x1000u) // phải khớp Stack_Size bạn đang dùng
#define PATTERN 0xA5A5A5A5u

static inline uint32_t* stack_bottom(void){
  return (uint32_t*)((uint32_t)&__initial_sp - STACK_SIZE_BYTES);
}
static inline uint32_t* stack_top(void){
  return (uint32_t*)&__initial_sp;
}

void StackPaint(void){
  uint32_t *p = stack_bottom();
  while (p < stack_top()) *p++ = PATTERN;
}

size_t StackHighWaterBytes(void){
  uint32_t *p = stack_bottom();
  while (p < stack_top() && *p == PATTERN) p++;
  return (size_t)((uint8_t*)stack_top() - (uint8_t*)p);
}
```

* Gọi `StackPaint()` **rất sớm** (đầu `main()` ngay sau `HAL_Init()` hoặc thậm chí trước nếu bạn chắc).
* Thỉnh thoảng log `StackHighWaterBytes()` ra UART/RTT.
* Nếu high-water tiến sát `STACK_SIZE_BYTES` (ví dụ >80–90%) ⇒ bạn gần overflow.

> Cách này bắt được cả “đã từng dùng tới đâu” dù hiện tại SP đã quay lên.

---

## 4) Bẫy HardFault để biết có phải stack đè bậy không (debug chuẩn)

Nếu stack overflow dẫn tới HardFault, hãy sửa handler để lấy:

* `MSP/PSP`
* `PC/LR`
* các thanh ghi stacked

Bạn có thể thêm HardFault handler “có log” (Keil) để in ra PC/LR hoặc dừng breakpoint, từ đó truy ra hàm nào làm stack bùng.

Nếu bạn muốn, bạn paste HardFault_Handler hiện tại của bạn, mình sẽ đưa bản “drop-in” phù hợp STM32/Keil để dump regs.

---

## 5) Những nguyên nhân phổ biến làm stack “phình” theo thời gian

Các “thủ phạm” hay gặp với HAL:

* **Mảng local lớn trong hàm** (đặc biệt trong callback IRQ, hoặc trong task loop)

  * VD: `uint8_t buf[2048];` đặt trong function → stack tăng đột biến.
  * Giải pháp: đưa ra **static/global**, hoặc cấp phát từ heap (cẩn thận), hoặc chia nhỏ.

* **printf/sprintf** (newlib/stdio) ăn stack mạnh và có thể phân mảnh heap

  * Giải pháp: dùng `snprintf` có giới hạn; hạn chế float format; dùng lightweight printf.

* **Recursion / call chain sâu** (đặc biệt trong state machine gọi lồng nhau)

  * Giải pháp: chuyển recursion thành vòng lặp, flatten call depth.

* **Interrupt lồng nhau / callback HAL** gọi nhiều tầng

  * ISR nên cực gọn; tránh gọi hàm nặng/printf trong ISR.

* **Heap/stack collision** (nếu bạn có malloc, hoặc thư viện dùng heap ngầm)

  * Tăng khoảng cách hoặc tắt heap nếu không dùng.

* **DMA buffer đặt trên stack** (rất nguy hiểm)

  * DMA cần buffer tồn tại lâu; đặt stack sẽ “mất” sau khi hàm return.

---

## 6) “Cách xử lý” nhanh nhất theo thực chiến (khuyên làm theo thứ tự)

1. **Tăng Stack_Size** lên 4KB/8KB để xem triệu chứng còn không.
2. Thêm **StackPaint + HighWater** để đo thực tế sau vài phút/hours chạy.
3. Nếu high-water cao:

   * tìm hàm gây phình (soát mảng local, printf, callback ISR)
   * chuyển buffer lớn ra global/static
   * giảm call depth
4. Nếu vẫn khó: thêm **HardFault dump** + bật map file để truy PC/LR.

---

## Để mình khoanh đúng hơn (không cần bạn trả lời dài)

Bạn chỉ cần paste 3 thứ là mình có thể chỉ chính xác chỗ set stack và viết đoạn đo đúng symbol Keil của project bạn:

1. Đoạn trong `startup_stm32g474xx.s` có `Stack_Size` / `__initial_sp`
2. Bạn đang set Stack_Size bao nhiêu (0x400? 0x800?)
3. Có dùng **FreeRTOS** không? (nếu có thì ngoài “main stack”, mỗi task còn stack riêng)

Bạn paste 20–40 dòng quanh `Stack_Size` là đủ.


Có. Với **Keil µVision (Arm Compiler) + STM32 HAL**, “một số tính năng chạy một thời gian rồi biến mất” rất hay gặp khi **stack overflow** hoặc **bị ghi đè RAM** (stack đè lên `.bss/.data`, heap, buffer DMA…). Dưới đây là các cách **bắt bệnh + xử lý** theo thứ tự hiệu quả/nhanh nhất.

---

## 1) Tăng stack đúng chỗ trong Keil (để loại trừ ngay)

Trong Keil, kích thước stack thường được quyết định bởi **startup file**:

* `startup_stm32g474xx.s` (hoặc tương tự)

  * Có các symbol như `Stack_Size` (và `Heap_Size`)

Bạn vào file startup và tìm đoạn kiểu:

```asm
Stack_Size      EQU     0x00000400
Heap_Size       EQU     0x00000200
```

➡️ Thử tăng `Stack_Size` lên **0x1000 (4KB)** hoặc **0x2000 (8KB)** để xem lỗi có biến mất không.

Ngoài ra kiểm tra trong µVision:

* **Project → Options for Target → Target**: đọc “IRAM1 size” đúng với RAM thật.
* **Options → Linker**: nếu dùng scatter file, stack/heap có thể nằm trong scatter thay vì startup.

> Nếu tăng stack mà hết hiện tượng → 90% là stack overflow hoặc gần overflow.

---

## 2) Bật “stack usage / runtime check” của Keil (bắt sớm)

Keil có cơ chế phát hiện stack/heap va chạm và stack overflow tùy cấu hình thư viện runtime.

Trong µVision:

* **Options for Target → C/C++**

  * bật **“One ELF Section per Function”** (giúp map dễ đọc, không bắt buộc)
* **Options for Target → Linker**

  * bật **Map File** (Output → Create MAP file)

Sau đó bạn có thể:

* xem **map file** để biết **stack đặt ở đâu**, còn trống bao nhiêu RAM.

Nếu bạn dùng **Microlib**, một số cơ chế check khác đi; nhưng map file vẫn là nguồn chuẩn.

---

## 3) Đo “stack high-water mark” ngay trên firmware (rất hiệu quả)

Ý tưởng: lúc boot, **fill vùng stack bằng pattern**, chạy một thời gian rồi **kiểm tra còn lại bao nhiêu pattern** ⇒ biết stack đã dùng tối đa bao nhiêu.

### Với Keil/ARMCC, cách làm thực dụng:

1. Tìm địa chỉ stack trong map / startup:

   * `__initial_sp` = đỉnh stack
   * vùng stack thường nằm cuối IRAM.

2. Bạn có thể “paint” một khoảng dưới `__initial_sp` (bạn biết kích thước stack bạn cấu hình) rồi kiểm tra.

Ví dụ C (không phụ thuộc symbol phức tạp, chỉ cần bạn khai báo đúng Stack_Size):

```c
#include <stdint.h>
#include <stddef.h>

extern uint32_t __initial_sp;      // Keil startup export
#define STACK_SIZE_BYTES (0x1000u) // phải khớp Stack_Size bạn đang dùng
#define PATTERN 0xA5A5A5A5u

static inline uint32_t* stack_bottom(void){
  return (uint32_t*)((uint32_t)&__initial_sp - STACK_SIZE_BYTES);
}
static inline uint32_t* stack_top(void){
  return (uint32_t*)&__initial_sp;
}

void StackPaint(void){
  uint32_t *p = stack_bottom();
  while (p < stack_top()) *p++ = PATTERN;
}

size_t StackHighWaterBytes(void){
  uint32_t *p = stack_bottom();
  while (p < stack_top() && *p == PATTERN) p++;
  return (size_t)((uint8_t*)stack_top() - (uint8_t*)p);
}
```

* Gọi `StackPaint()` **rất sớm** (đầu `main()` ngay sau `HAL_Init()` hoặc thậm chí trước nếu bạn chắc).
* Thỉnh thoảng log `StackHighWaterBytes()` ra UART/RTT.
* Nếu high-water tiến sát `STACK_SIZE_BYTES` (ví dụ >80–90%) ⇒ bạn gần overflow.

> Cách này bắt được cả “đã từng dùng tới đâu” dù hiện tại SP đã quay lên.

---

## 4) Bẫy HardFault để biết có phải stack đè bậy không (debug chuẩn)

Nếu stack overflow dẫn tới HardFault, hãy sửa handler để lấy:

* `MSP/PSP`
* `PC/LR`
* các thanh ghi stacked

Bạn có thể thêm HardFault handler “có log” (Keil) để in ra PC/LR hoặc dừng breakpoint, từ đó truy ra hàm nào làm stack bùng.

Nếu bạn muốn, bạn paste HardFault_Handler hiện tại của bạn, mình sẽ đưa bản “drop-in” phù hợp STM32/Keil để dump regs.

---

## 5) Những nguyên nhân phổ biến làm stack “phình” theo thời gian

Các “thủ phạm” hay gặp với HAL:

* **Mảng local lớn trong hàm** (đặc biệt trong callback IRQ, hoặc trong task loop)

  * VD: `uint8_t buf[2048];` đặt trong function → stack tăng đột biến.
  * Giải pháp: đưa ra **static/global**, hoặc cấp phát từ heap (cẩn thận), hoặc chia nhỏ.

* **printf/sprintf** (newlib/stdio) ăn stack mạnh và có thể phân mảnh heap

  * Giải pháp: dùng `snprintf` có giới hạn; hạn chế float format; dùng lightweight printf.

* **Recursion / call chain sâu** (đặc biệt trong state machine gọi lồng nhau)

  * Giải pháp: chuyển recursion thành vòng lặp, flatten call depth.

* **Interrupt lồng nhau / callback HAL** gọi nhiều tầng

  * ISR nên cực gọn; tránh gọi hàm nặng/printf trong ISR.

* **Heap/stack collision** (nếu bạn có malloc, hoặc thư viện dùng heap ngầm)

  * Tăng khoảng cách hoặc tắt heap nếu không dùng.

* **DMA buffer đặt trên stack** (rất nguy hiểm)

  * DMA cần buffer tồn tại lâu; đặt stack sẽ “mất” sau khi hàm return.

---

## 6) “Cách xử lý” nhanh nhất theo thực chiến (khuyên làm theo thứ tự)

1. **Tăng Stack_Size** lên 4KB/8KB để xem triệu chứng còn không.
2. Thêm **StackPaint + HighWater** để đo thực tế sau vài phút/hours chạy.
3. Nếu high-water cao:

   * tìm hàm gây phình (soát mảng local, printf, callback ISR)
   * chuyển buffer lớn ra global/static
   * giảm call depth
4. Nếu vẫn khó: thêm **HardFault dump** + bật map file để truy PC/LR.

---

## Để mình khoanh đúng hơn (không cần bạn trả lời dài)

Bạn chỉ cần paste 3 thứ là mình có thể chỉ chính xác chỗ set stack và viết đoạn đo đúng symbol Keil của project bạn:

1. Đoạn trong `startup_stm32g474xx.s` có `Stack_Size` / `__initial_sp`
2. Bạn đang set Stack_Size bao nhiêu (0x400? 0x800?)
3. Có dùng **FreeRTOS** không? (nếu có thì ngoài “main stack”, mỗi task còn stack riêng)

Bạn paste 20–40 dòng quanh `Stack_Size` là đủ.


### 1) “Stack của STM32G474” là bao nhiêu?

**STM32G474 không có một “dung lượng stack cố định”.** Stack chỉ là **một vùng bạn dành ra trong SRAM** và **kích thước do linker/startup của project quyết định** (ví dụ `_Min_Stack_Size` trong file `.ld`, hoặc `__ICFEDIT_size_cstack__` với IAR, v.v.).

Con **STM32G474 (Cortex-M4)** có tổng RAM nội khá lớn, gồm:

* **96 KB SRAM** + **32 KB CCM SRAM (routine booster)** (tổng 128 KB) theo datasheet. ([STMicroelectronics][1])

Nhưng **stack chỉ lấy một phần** của RAM đó (phần còn lại cho `.data/.bss`, heap, buffer, RTOS task stacks…).

> Nhiều project mẫu / mặc định của STM32CubeIDE/IAR hay để stack rất nhỏ kiểu **0x400 (1024 byte)** và heap **0x200**, nhưng đó chỉ là **default của template**, không phải giới hạn phần cứng. ([community.st.com][2])

---

### 2) Khi nào biết stack “hết” (stack overflow)?

Trên Cortex-M, stack thường **tăng từ địa chỉ cao xuống thấp**. Khi **SP (MSP/PSP) chạy xuống thấp hơn đáy vùng stack bạn cấp**, là overflow. Thực tế bạn hay “biết” qua 3 cách:

#### Cách A — Bị crash/HardFault (dấu hiệu muộn)

Overflow có thể **đè lên biến global/heap/stack khác**, gây:

* HardFault / MemManageFault (nếu có bảo vệ),
* chương trình “chạy lung tung”, dữ liệu sai, reset ngẫu nhiên…

#### Cách B — Đo “high-water mark” bằng canary pattern (cách thực dụng nhất)

Ý tưởng: lúc boot, **đổ một pattern** (vd `0xA5`) vào toàn bộ vùng stack; chạy một thời gian rồi **đếm xem pattern bị ghi đè đến đâu** → biết stack đã dùng tối đa bao nhiêu. Đây là cách rất phổ biến trong embedded. ([MCU on Eclipse][3])

Ví dụ (GCC/CubeIDE, dựa vào symbol của linker – bạn cần đúng tên symbol theo project của bạn):

```c
#include <stdint.h>
#include <stddef.h>

// Tùy linker script, tên symbol có thể là: _estack, _sstack, __StackTop, __StackLimit...
extern uint32_t __StackLimit;   // đáy stack (địa chỉ thấp)
extern uint32_t __StackTop;     // đỉnh stack (địa chỉ cao)

#define STACK_PATTERN 0xA5A5A5A5u

void StackPaint(void) {
  uint32_t *p = &__StackLimit;
  while (p < &__StackTop) {
    *p++ = STACK_PATTERN;
  }
}

size_t StackHighWaterBytes(void) {
  uint32_t *p = &__StackLimit;
  while (p < &__StackTop && *p == STACK_PATTERN) {
    p++;
  }
  return (size_t)((uint8_t*)&__StackTop - (uint8_t*)p); // số byte đã từng bị dùng tối đa
}
```

* Gọi `StackPaint()` rất sớm (đầu `main()` sau init tối thiểu).
* Thỉnh thoảng gọi `StackHighWaterBytes()` để log/telemetry.

#### Cách C — Bảo vệ bằng MPU “guard band” (phát hiện sớm)

Bạn có thể cấu hình **MPU** đặt **một vùng “no-access” ngay dưới đáy stack**. Khi stack chạm vào sẽ tạo fault ngay, dễ debug. (STM32G474 có MPU vì là Cortex-M4). ([STMicroelectronics][1])

---

### 3) Biết trước (compile-time) stack có đủ không?

* Dùng **phân tích tĩnh** (static stack analysis) / báo cáo stack usage của compiler. STM32CubeIDE có công cụ liên quan, nhưng vẫn cần bạn theo dõi vì nó không luôn “bắt lỗi” theo RAM thực tế. ([Electrical Engineering Stack Exchange][4])
* Với GCC, bạn cũng có thể bật `-fstack-usage` để tạo file `.su` cho từng hàm (rất hữu ích khi nghi hàm nào ăn stack).

---

### Gợi ý nhanh để bạn tự kiểm tra project của mình

1. Mở file linker (`*.ld`) và tìm `_Min_Stack_Size` (hoặc tương đương) → đó là **stack bạn đang cấp**.
2. Chạy firmware, bật **canary/high-water mark** để biết “đỉnh dùng” thực tế.
3. Chừa **margin** (thường 30–50% tùy mức an toàn) và đặc biệt cẩn thận với:

   * mảng local lớn (`uint8_t buf[4096];`),
   * `printf`/`sprintf`,
   * recursion,
   * ISR gọi hàm sâu,
   * RTOS (mỗi task có stack riêng).

Nếu bạn cho mình biết bạn đang dùng **bare-metal hay FreeRTOS**, và toolchain **CubeIDE (GCC) / Keil / IAR**, mình sẽ chỉ đúng vị trí stack setting + đúng tên symbol để đo high-water mark “chuẩn bài” cho project của bạn.

[1]: https://www.st.com/resource/en/datasheet/stm32g474cb.pdf "Datasheet - STM32G474xB STM32G474xC STM32G474xE - Arm® Cortex®-M4 32-bit MCU+FPU, 170 MHz / 213 DMIPS, 128 KB SRAM, rich analog, math acc, 184 ps 12 chan Hi-res timer"
[2]: https://community.st.com/t5/stm32cubeide-mcus/stmcubeide-defaults/td-p/357299?utm_source=chatgpt.com "STMCubeIDE Defaults - STMicroelectronics Community"
[3]: https://mcuoneclipse.com/2023/02/19/avoiding-stack-overflows-application-monitoring-the-stack-usage/?utm_source=chatgpt.com "Avoiding Stack Overflows: Application Monitoring the Stack Usage"
[4]: https://electronics.stackexchange.com/questions/649820/how-to-use-stm32cube-static-stack-analyzer-as-an-automatic-compile-time-sanity-c?utm_source=chatgpt.com "stm32 - How to use STM32Cube Static Stack Analyzer as an automatic ..."
